struct Solution;

impl Solution {
    pub fn exclusive_time(n: i32, logs: Vec<String>) -> Vec<i32> {
        let mut res = vec![0; n as usize];
        let mut stack: Vec<i32> = Vec::new();
        let mut prev_time = 0;

        println!("{}, num function", n);
        for log in logs {
            let parts: Vec<&str> = log.split(':').collect();
            let fid: i32 = parts[0].parse().unwrap();
            let is_start = parts[1] == "start";
            let curr_time: i32 = parts[2].parse().unwrap();

            if is_start {
                if let Some(&top_fid) = stack.last() {
                    res[top_fid as usize] += curr_time - prev_time;
                }
                stack.push(fid);
                prev_time = curr_time;
            } else {
                let top_fid = stack.pop().unwrap();
                res[top_fid as usize] += curr_time - prev_time + 1;
                prev_time = curr_time + 1;
            }
        }

        res
    }
}

fn main() {
    let n = 2;
    let logs = vec![
        "0:start:0".to_string(), // 0-р функц 0 хугацаанд эхэлж, 2 нэгж хугацаа (0 ба 1) ажиллана.
        "1:start:2".to_string(), // 1-р функц 2 хугацаанд эхэлж, 4 нэгж хугацаа (2, 3, 4, 5) ажиллаад 5 дээр дуусна.
        "1:end:5".to_string(), //0-р функц 6 хугацаанд үргэлжлэн ажиллаж, 1 нэгж хугацаа (6) ажиллаад дуусна.
        "0:end:6".to_string(),
    ];

    let result = Solution::exclusive_time(n, logs);

    println!("Exclusive times: {:?}", result);
    // Output: [3, 4]
}

// Функцүүдийн цэвэр ажиллах хугацаа (Exclusive Time of Functions)
// Нэг урсгалтай (single-threaded) CPU дээр бид n тооны функцээс бүрдэх програм ажиллуулж байна. Функц бүр 0-ээс n−1 хүртэлх үл давтагдах ID-тай.
// Функцийн дуудлагуудыг call stack (дуудлагын стек) ашиглан хадгалдаг:
//     Функц дуудагдаж эхлэхэд түүний ID стек рүү орно (push).
//     Функц ажиллаж дуусахад түүний ID стекээс гарна (pop).
//     Стекийн хамгийн дээр байгаа ID-тай функц нь тухайн агшинд ажиллаж байгаа функц юм.
// Функц эхлэх эсвэл дуусах бүрд бид дараах хэлбэртэй лог (log) бичнэ: "{function_id}:{"start" | "end"}:{timestamp}".
//     Жишээ нь: "0:start:3" гэвэл ID 0-тэй функц 3 дахь хугацааны нэгжийн эхэнд эхэлсэн, харин "1:end:2" гэвэл ID 1-тэй функц 2 дахь хугацааны нэгжийн төгсгөлд дууссаныг илэрхийлнэ.
// Анхаар: Нэг функцийг олон удаа, тэр дундаа рекурсив байдлаар (өөрийгөө дуудах) ажиллуулж болно.
// Функцийн цэвэр ажиллах хугацаа (exclusive time) гэдэг нь тухайн функцийн бүх дуудлагуудын ажилласан хугацааны нийлбэр юм. Хэрэв функц өөр нэг функцийг дуудвал, дуудагдсан функц ажиллаж байх хооронд үндсэн функцийн хугацаа тоологдохгүй.
// Даалгавар: Бүх функцүүдийн цэвэр ажиллах хугацааг жагсаалт (array) хэлбэрээр буцаа. Жагсаалтын i дахь индекс дэх утга нь i ID-тай функцийн нийт ажилласан хугацаа байна.
// Жишээ 1:
// Оролт: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"] Гаралт: [3, 4] Тайлбар:
//     0-р функц 0 хугацаанд эхэлж, 2 нэгж хугацаа (0 ба 1) ажиллана.
//     1-р функц 2 хугацаанд эхэлж, 4 нэгж хугацаа (2, 3, 4, 5) ажиллаад 5 дээр дуусна.
//     0-р функц 6 хугацаанд үргэлжлэн ажиллаж, 1 нэгж хугацаа (6) ажиллаад дуусна.
//     Нийт: 0-р функц 2+1=3 нэгж, 1-р функц 4 нэгж хугацаа тус тус ажилласан.
// Жишээ 2:
// Оролт: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"] Гаралт: [8] Тайлбар: 0-р функц өөрийгөө рекурсив байдлаар дуудаж байгаа тул нийт ажилласан бүх хугацаа нь нэг функцэд (ID 0) хамаарна: 2+4+1+1=8.
// Хязгаарлалтууд:
//     1≤n≤100
//     2≤logs.length≤500
//     0≤function_id<n
//     0≤timestamp≤109
//     Хоёр "start" лог нэгэн зэрэг (ижил timestamp дээр) бүртгэгдэхгүй.
//     Хоёр "end" лог нэгэн зэрэг бүртгэгдэхгүй.
//     "start" лог бүрд харгалзах "end" лог заавал байна.
