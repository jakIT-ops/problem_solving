struct Solution;

impl Solution {
    pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {
        let mut answer = prices.clone();
        let n = prices.len();

        for i in 0..n {
            for j in i + 1..n {
                if prices[j] <= prices[i] {
                    answer[i] = prices[i] - prices[j];
                    break;
                }
            }
        }
        answer
    }
}
// impl Solution {
//     pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {
//         let mut answer = prices.clone();
//         let n = prices.len();
//
//         for i in 0..n {
//             for j in i + 1..n {
//                 if prices[j] <= prices[i] {
//                     answer[i] = prices[i] - prices[j];
//                     break;
//                 }
//             }
//         }
//         answer
//     }
// }

fn main() {
    // Жишээ 1: [8, 4, 6, 2, 3] -> Output: [4, 2, 4, 2, 3]
    let prices1 = vec![8, 4, 6, 2, 3];
    let result1 = Solution::final_prices(prices1);
    println!("Test 1 - Input: [8, 4, 6, 2, 3]");
    println!("Test 1 - Result: {:?}", result1);

    // Жишээ 2: [1, 2, 3, 4, 5] -> Output: [1, 2, 3, 4, 5]
    let prices2 = vec![1, 2, 3, 4, 5];
    let result2 = Solution::final_prices(prices2);
    println!("\nTest 2 - Input: [1, 2, 3, 4, 5]");
    println!("Test 2 - Result: {:?}", result2);

    // Жишээ 3: [10, 1, 1, 6] -> Output: [9, 0, 1, 6]
    let prices3 = vec![10, 1, 1, 6];
    let result3 = Solution::final_prices(prices3);
    println!("\nTest 3 - Input: [10, 1, 1, 6]");
    println!("Test 3 - Result: {:?}", result3);
}

// ### Q1. Дэлгүүрийн хямдралтай эцсийн үнэ
// Энэхүү бодлого нь **Monotonic Stack** (нэгэн хэвийн дараалалтай стек) ашиглан бодвол хамгийн үр дүнтэй боловч анхан шатанд
// "Brute Force" буюу давхар давталтаар бодож болно.
//
// Танд `prices` нэртэй бүхэл тоон хүснэгт өгөгдсөн. `prices[i]` нь дэлгүүрт байгаа  дахь барааны үнэ юм.
//
// Дэлгүүрт нэгэн тусгай хямдрал зарлагдсан байгаа:
// Хэрэв та  дахь барааг худалдаж авбал, танд `prices[j]`-тэй тэнцүү хямдрал үзүүлнэ. Энд  нь  бөгөөд
// байх хамгийн бага индекс (хамгийн ойрын дараагийн бараа) байна. Хэрэв тийм бараа олдохгүй бол та ямар ч хямдрал авахгүй.

//
// Энэхүү бодлогын гол логик нь "өөрийнх нь баруун гар талд байгаа, өөртэй нь ижилхэн эсвэл бага үнэтэй хамгийн эхний барааг олох" юм. Үүнийг бид "Next Smaller Element" асуудал гэж нэрлэдэг.
// Жишээ бүрийг алхам алхмаар задалж үзье: Жишээ 1: prices = [8, 4, 6, 2, 3] Энд бараа бүрийн хувьд баруун тийшээ харж, өөрөөс нь бага буюу тэнцүү (≤) үнийг хайна.
//     Бараа 0 (8₮): Баруун талд байгаа бараанууд: [4, 6, 2, 3]. Хамгийн эхний бага үнэ бол 4.
//         Тооцоолол: 8−4= 4₮
//     Бараа 1 (4₮): Баруун талд байгаа бараанууд: [6, 2, 3]. Хамгийн эхний бага үнэ бол 2.
//         Тооцоолол: 4−2= 2₮
//     Бараа 2 (6₮): Баруун талд байгаа бараанууд: [2, 3]. Хамгийн эхний бага үнэ бол 2.
//         Тооцоолол: 6−2= 4₮
//     Бараа 3 (2₮): Баруун талд байгаа бараанууд: [3]. 3 нь 2-оос их тул хямдрал олдохгүй.
//         Тооцоолол: 2₮ (хэвээрээ)
//     Бараа 4 (3₮): Баруун талд өөр бараа байхгүй.
//         Тооцоолол: 3₮ (хэвээрээ)
//
// Үр дүн: [4, 2, 4, 2, 3]

// Жишээ 2: prices = [1, 2, 3, 4, 5]
//
// Энэ жишээнд үнэ байнга өсөж байна.
//     1-ийн баруун талд 1-ээс бага тоо байхгүй.
//     2-ын баруун талд 2-оос бага тоо байхгүй.
//     ...гэх мэт. Бүх барааны үнэ хэвээрээ үлдэнэ.
//
// Үр дүн: [1, 2, 3, 4, 5]
// Жишээ 3: prices = [10, 1, 1, 6]
//
// Энд үнэ тэнцүү байх тохиолдлыг анхаарах хэрэгтэй.
//     Бараа 0 (10₮): Дараагийн бага үнэ бол 1 (index=1).
//         Тооцоолол: 10−1= 9₮
//     Бараа 1 (1₮): Дараагийн бараа нь 1 (index=2). Энэ нь өөртэй нь тэнцүү тул хямдрал болж ашиглагдана.
//         Тооцоолол: 1−1= 0₮
//     Бараа 2 (1₮): Дараагийн бараа нь 6. 6 нь 1-ээс их тул хямдрал байхгүй.
//         Тооцоолол: 1₮
//     Бараа 3 (6₮): Дараа нь бараа байхгүй.
//         Тооцоолол: 6₮
//
// Үр дүн: [9, 0, 1, 6]

// Стек (Stack) ашиглан бодох логик зураглал:
//
// Бид бараануудыг стек рүү дараалан хийхдээ: "Хэрэв шинээр орж ирж буй барааны үнэ стекийн орой
// дээр байгаа барааны үнээс бага буюу тэнцүү байвал хямдрал ирлээ" гэж үзэж стекийг суллана.
// Алхам	Үйлдэл	Стек (Индексүүд)	Үр дүнгийн хүснэгт (Answer)
// 1	8 орж ирэв	[0]	[8, 4, 6, 2, 3]
// 2	4 орж ирэв (4≤8)	Стекээс 0-ийг гаргаж: 8−4	[4, 4, 6, 2, 3]
// 3	6 орж ирэв	[1, 2]	[4, 4, 6, 2, 3]
// 4	2 орж ирэв (2≤6 ба 2≤4)	2,1 индексийг гаргаж хямдруулна	[4, 2, 4, 2, 3]
//
// Та энэхүү "Next Smaller Element" логикийг өөр хаана (жишээ нь: байшингуудын сүүдэр, температур) ашиглаж болох талаар сонирхож байна уу?

//////////////////// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ### Стек (Stack) ашиглан илүү үр дүнтэй бодох нь ():
//
// Хэрэв та өмнөх Rust бодлого дээрээ (Exclusive Time) Стек ашиглаж үзсэн бол энэ арга илүү сонирхолтой байх болно.
// үнэ нь буурч байгаа индексийг стек-д хадгалаад, дараагийн бага үнэ орж ирэх үед стек-ээс гарган хямдралыг нь тооцно.
//
// ```rust
// impl Solution {
//     pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {
//         let mut ans = prices.clone();
//         let mut stack = Vec::new(); // Индексүүдийг хадгалах стек
//
//         for i in 0..prices.len() {
//             // Стекийн орой дээр байгаа барааны үнэ одоогийн бараанаас их бол
//             // Хямдрал үзүүлэх нөхцөл бүрдлээ гэсэн үг
//             while !stack.is_empty() && prices[*stack.last().unwrap()] >= prices[i] {
//                 let idx = stack.pop().unwrap();
//                 ans[idx] -= prices[i];
//             }
//             stack.push(i);
//         }
//         ans
//     }
// }
//
// **Зөвлөмж:**
//
// * `Example 3`-т байгаа `[10, 1, 1, 6]` жишээг анхаараарай. 0-р бараа (10) нь 1-р бараа (1)-ээр хямдраад **9** болно. 1-р бараа (1) нь 2-р бараа (1)-ээр хямдраад **0** болно.
// Хэдийгээр үнэ нь ижил байсан ч () хямдрал үйлчилнэ гэдгийг санаарай.
//
// **Дараагийн алхам болгож энэ бодлогын Стек ашигласан хувилбарыг Rust-ийн `while let` ашиглан илүү "Rusty" хэлбэрт оруулж бичиж үзэх үү?**
// "start" лог бүрд харгалзах "end" лог заавал байна.
